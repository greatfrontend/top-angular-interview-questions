---
title: How do you manually trigger change detection?
---

## TL;DR

You might need to manually trigger change detection in Angular, especially when using the `OnPush` change detection strategy or when working outside of Angular's Zone.js environment (like with Web Workers or certain third-party libraries).

The primary ways to manually trigger change detection are:

- `ChangeDetectorRef.detectChanges()`: Runs change detection for the current component and its descendants. Use this when you know a change has occurred within the component's view or its children that Angular might not otherwise detect.
- `ChangeDetectorRef.markForCheck()`: Marks the component and its ancestors as needing to be checked during the _next_ change detection cycle. It doesn't trigger the check immediately. This is the preferred method when using `OnPush`, as it efficiently signals Angular that a relevant input or observable has emitted, ensuring the component is checked during the next global tick.
- `ApplicationRef.tick()`: Triggers change detection for the _entire_ application. This is less common for component-specific updates and more for global scenarios or testing.

```typescript
import {
  Component,
  ChangeDetectorRef,
  ChangeDetectionStrategy,
  ApplicationRef,
} from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `
    <p>{{ message }}</p>
    <button (click)="updateMessage()">Update Message (Manual CD)</button>
  `,
  // Often used with OnPush strategy
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class MyComponent {
  message = 'Initial message';

  constructor(private cdr: ChangeDetectorRef, private appRef: ApplicationRef) {}

  updateMessage() {
    // Example: Updating data outside Zone.js or when using OnPush
    this.message = 'Message updated at ' + new Date().toLocaleTimeString();

    // Choose one method depending on the scenario:

    // Method 1: Trigger change detection for this component and its children
    this.cdr.detectChanges();

    // Method 2: Mark this component and ancestors for check (common with OnPush)
    // This is usually sufficient and more performant than detectChanges()
    // this.cdr.markForCheck();

    // Method 3: Trigger change detection for the entire application
    // this.appRef.tick();
  }
}
```

---

## Understanding Angular's default change detection

By default, Angular uses Zone.js to automatically detect changes. Zone.js patches asynchronous browser APIs (like `setTimeout`, `setInterval`, `XMLHttpRequest`, event listeners) and notifies Angular whenever one of these operations completes. Angular then runs its change detection mechanism to check the component tree and update the DOM if necessary.

This automatic detection works well for most applications, but there are scenarios where you might need more control.

## Why manually trigger change detection?

Manual triggering is typically required in these situations:

### Using the OnPush change detection strategy

When a component uses `ChangeDetectionStrategy.OnPush`, Angular only checks it under specific conditions:

- Its inputs change (by reference).
- It emits an event.
- An observable linked via the `async` pipe emits a new value.
- You manually trigger change detection.

If you mutate an input object or array (instead of providing a new reference) or update component state based on something not covered by the above (e.g., a `setTimeout` _inside_ the component that doesn't trigger Zone.js correctly, or a third-party library callback), Angular won't detect the change automatically with `OnPush`.

### Working outside Zone.js

If you are running code outside of Angular's Zone (e.g., in a Web Worker, or integrating with a library that doesn't run within the Angular zone), changes made in that code won't automatically trigger Angular's change detection.

### Detaching the change detector

You can detach a component's change detector using `ChangeDetectorRef.detach()`. This stops Angular from automatically checking that component and its subtree. You would then need to manually trigger checks using `detectChanges()` when needed. This is an advanced technique for performance optimization in specific cases.

## Methods for manual triggering

Angular provides the `ChangeDetectorRef` and `ApplicationRef` services to manually control change detection.

### ChangeDetectorRef.detectChanges()

- **What it does:** Runs change detection for the _current component and its entire subtree_ (all its children and their children, etc.), regardless of their `ChangeDetectionStrategy`.
- **When to use:**
  - When you have detached the change detector (`detach()`) and need to explicitly check the component and its children.
  - When you know a change has occurred within the component's view or a child's view that `OnPush` or Zone.js might miss, and you need the update to reflect immediately.
  - In integration tests to force an update after manipulating component state.
- **Considerations:** Can be less performant than `markForCheck()` if used excessively, as it checks the entire subtree.

```typescript
import { Component, ChangeDetectorRef } from '@angular/core';

@Component({
  selector: 'app-manual-detect',
  template: `
    <p>Value: {{ value }}</p>
    <button (click)="updateValue()">Update</button>
  `,
})
export class ManualDetectComponent {
  value = 0;

  constructor(private cdr: ChangeDetectorRef) {}

  updateValue() {
    this.value++;
    // Manually trigger detection for this component and its children
    this.cdr.detectChanges();
  }
}
```

### ChangeDetectorRef.markForCheck()

- **What it does:** Marks the component as "dirty" (needs to be checked) and also marks all its ancestors up to the root component. It _does not_ trigger change detection immediately. It ensures that the component will be checked during the _next_ change detection cycle, whether that cycle is triggered by Zone.js or `ApplicationRef.tick()`.
- **When to use:**
  - This is the **preferred method when using `ChangeDetectionStrategy.OnPush`**. If you update component state (e.g., a private property) based on an asynchronous operation or an input mutation that doesn't trigger `OnPush` automatically, call `markForCheck()` to tell Angular that this component needs to be included in the next check.
  - When you update data in a service that the component relies on, and the component uses `OnPush`.
- **Considerations:** It's more performant than `detectChanges()` because it doesn't immediately traverse the subtree. It just marks the path for the next global check.

```typescript
import {
  Component,
  ChangeDetectorRef,
  ChangeDetectionStrategy,
} from '@angular/core';

@Component({
  selector: 'app-mark-for-check',
  template: `
    <p>Count: {{ count }}</p>
    <button (click)="increment()">Increment</button>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush, // Using OnPush
})
export class MarkForCheckComponent {
  count = 0;

  constructor(private cdr: ChangeDetectorRef) {}

  increment() {
    // Update component state
    this.count++;
    console.log('Count updated:', this.count);

    // Mark component for check - necessary with OnPush
    // The view will update during the next CD cycle (e.g., from button click event)
    this.cdr.markForCheck();
  }
}
```

In the example above, the button click event itself triggers a Zone.js microtask, which leads to a change detection cycle. `markForCheck()` ensures that _this specific component_ is included in that cycle, even though its input didn't change and it didn't emit an event. If the `count` was updated by something _not_ triggering Zone.js (like a WebSocket message received outside the zone), `markForCheck()` would still be needed, and you might also need `detectChanges()` or rely on another Zone-triggered event to eventually run the check. However, `markForCheck()` is generally safer and more efficient with `OnPush`.

### ApplicationRef.tick()

- **What it does:** Triggers a change detection cycle for the _entire application_, starting from the root component. It's equivalent to Angular's default behavior when Zone.js detects a change.
- **When to use:**
  - In testing scenarios to simulate a full change detection cycle.
  - When running code completely outside of Zone.js (e.g., in a Web Worker) and you need to update the entire application's view based on results from the worker.
  - Less commonly used for component-specific updates compared to `ChangeDetectorRef`.
- **Considerations:** This is the most heavy-handed approach as it checks the whole application tree.

```typescript
import { Component, ApplicationRef } from '@angular/core';

@Component({
  selector: 'app-app-tick',
  template: `
    <p>Status: {{ status }}</p>
    <button (click)="updateStatus()">Update Status (App Tick)</button>
  `,
})
export class AppTickComponent {
  status = 'Initial';

  constructor(private appRef: ApplicationRef) {}

  updateStatus() {
    this.status = 'Updated at ' + new Date().toLocaleTimeString();
    console.log('Status updated:', this.status);

    // Trigger change detection for the entire application
    this.appRef.tick();
  }
}
```

## Choosing the right method

- **For `OnPush` components:** Prefer `ChangeDetectorRef.markForCheck()`. It's the most efficient way to signal that the component needs checking during the next cycle.
- **For detached components:** Use `ChangeDetectorRef.detectChanges()` to explicitly check the component and its subtree when needed.
- **For global updates or testing outside Zone:** Use `ApplicationRef.tick()`.
- **Avoid `detectChanges()` on `OnPush` components unless strictly necessary** (e.g., you need an immediate update _within_ a complex interaction or animation frame that `markForCheck` might miss before the next tick). `markForCheck` is generally sufficient and better aligns with the `OnPush` philosophy.

## Further reading

- [Angular Documentation: Change Detection](https://angular.dev/guide/change-detection)
- [Angular Documentation: ChangeDetectorRef](https://angular.dev/api/core/ChangeDetectorRef)
- [Angular Documentation: ApplicationRef](https://angular.dev/api/core/ApplicationRef)
- [Angular Documentation: NgZone](https://angular.dev/api/core/NgZone)
